add tests for there are no more questions
tests for if not enough users for the questions
unit tests for funciotns of scripts in app

>

@view_config(route_name="about", renderer='templates/faqpage.jinja2')
def faq(request):
    return {}


def make_data(question, user):
    """Gets data from the database and parses it for the Guess function"""
    u, questions = _get_data(user, question)
    users, questions = _select_users(u, questions)
    x = _parse_into_matrix(questions, users)
    y = []
    for user_ in users:
        y.append(Submission.get_answer(user_, question))
    u = [sub.answer for sub in Submission.get_all_for_user(user)]
    return x, u, y


def _select_users(u, questions):
    _u = [u.pop()]
    _q = []
    while u:
        item = u.pop()
        qu = questions.pop()
        if len(item) >= 10:
            _u.append(item)
            _q.append(qu)

    users = _u[0]
    for item in _u:
            users = list(
                set(users) & set(item)
            )
    return users, _q


def _get_data(user, question):
    """Queries database for all the questions the user has answered
    then queries for all the users that have answered all those
    questions plus the question that the user is currently answering"""
    users = []
    questions = [Question.get_question_by_id(sub.question_id)
                 for sub in Submission.get_all_for_user(user)
                 ]

    for q in questions:
        users.append([User.get_by_id(sub.user_id)
                      for sub in Submission.get_all_for_question(q)
                      ])
    users.append([User.get_by_id(sub.user_id)
                  for sub in Submission.get_all_for_question(question)
                  ])
    return users, questions


def _parse_into_matrix(questions, users):
    """Sets matrix x to have a column for each question the
    user has answered, and fills each column with answers that
    the users have answered in the same order for each column"""
    x = [[] for q in range(len(questions))]
    for i, slot in enumerate(x):
        for user in users:
            slot.append(Submission.get_answer(user, questions[i]))
    return x


def guess(every_answer, user_answers, cur_question):
    n = len(every_answer[0])
    for each in every_answer:
        if len(each) != n:
            raise Exception("Every list must be of the same length, asshole.")
    every_answer.append(np.ones(n))
    A = np.vstack(every_answer).T
    every_x = np.linalg.lstsq(A, cur_question)[0]
    total = 0
    user_answers.append(1)  # the last value in every_x is c.
    for the_x, u_ans in zip(every_x, user_answers):
        total += u_ans * the_x
    if total > 5:
        total = 5
    elif total < 1:
        total = 1
    return total